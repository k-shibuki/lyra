<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lyra Evidence Dashboard - DPP-4i vs SGLT2i Comparison</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=IBM+Plex+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-primary: #0a0e14;
      --bg-secondary: #121820;
      --bg-card: #1a222d;
      --bg-hover: #242d3a;
      --border: #2d3748;
      --accent-support: #10b981;
      --accent-refute: #ef4444;
      --accent-neutral: #64748b;
      --accent-primary: #6366f1;
      --accent-secondary: #8b5cf6;
      --accent-dpp4i: #f59e0b;
      --accent-sglt2i: #06b6d4;
      --text-primary: #f1f5f9;
      --text-secondary: #94a3b8;
      --text-muted: #64748b;
      --gradient-1: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      --gradient-2: linear-gradient(135deg, #f59e0b 0%, #f97316 100%);
      --gradient-3: linear-gradient(135deg, #06b6d4 0%, #0ea5e9 100%);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'IBM Plex Sans', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      line-height: 1.6;
    }

    header {
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      padding: 1.5rem 2rem;
      position: sticky;
      top: 0;
      z-index: 100;
      backdrop-filter: blur(10px);
    }

    .header-content {
      max-width: 1800px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .logo-icon {
      width: 40px;
      height: 40px;
      background: var(--gradient-1);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 1.2rem;
    }

    h1 {
      font-size: 1.5rem;
      font-weight: 600;
      background: var(--gradient-1);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      color: var(--text-secondary);
      font-size: 0.875rem;
      margin-top: 0.25rem;
    }

    .task-toggle {
      display: flex;
      gap: 0.5rem;
      background: var(--bg-card);
      padding: 0.25rem;
      border-radius: 10px;
      border: 1px solid var(--border);
    }

    .task-btn {
      padding: 0.5rem 1.25rem;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.875rem;
      font-weight: 500;
      transition: all 0.2s ease;
      background: transparent;
      color: var(--text-secondary);
    }

    .task-btn:hover {
      color: var(--text-primary);
      background: var(--bg-hover);
    }

    .task-btn.active {
      color: var(--bg-primary);
      font-weight: 600;
    }

    .task-btn[data-task="dpp4i"].active {
      background: var(--accent-dpp4i);
    }

    .task-btn[data-task="sglt2i"].active {
      background: var(--accent-sglt2i);
    }

    .task-btn[data-task="compare"].active {
      background: var(--gradient-1);
      color: white;
    }

    main {
      max-width: 1800px;
      margin: 0 auto;
      padding: 2rem;
    }

    .summary-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .summary-card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.25rem;
      transition: all 0.2s ease;
    }

    .summary-card:hover {
      border-color: var(--accent-primary);
      transform: translateY(-2px);
    }
    
    .metrics-definition {
      margin-bottom: 1.5rem;
    }
    
    .metrics-definition details summary::-webkit-details-marker {
      display: none;
    }
    
    .metrics-definition details[open] summary {
      margin-bottom: 0;
    }

    .card-label {
      font-size: 0.75rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.5rem;
    }

    .card-value {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 2rem;
      font-weight: 600;
    }

    .card-value.dpp4i { color: var(--accent-dpp4i); }
    .card-value.sglt2i { color: var(--accent-sglt2i); }
    .card-value.support { color: var(--accent-support); }
    .card-value.refute { color: var(--accent-refute); }

    .card-detail {
      font-size: 0.875rem;
      color: var(--text-secondary);
      margin-top: 0.25rem;
    }

    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1.5rem;
    }

    @media (max-width: 1200px) {
      .dashboard-grid {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 16px;
      overflow: hidden;
    }

    .panel-header {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .panel-title {
      font-size: 1rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .panel-title-icon {
      width: 24px;
      height: 24px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.875rem;
    }

    .panel-body {
      padding: 1.5rem;
      min-height: 400px;
    }

    .panel-full {
      grid-column: 1 / -1;
    }

    .panel-insight {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.05) 100%);
      border-left: 3px solid var(--accent-primary);
      padding: 1rem 1.25rem;
      margin-top: 1rem;
      border-radius: 0 8px 8px 0;
      font-size: 0.875rem;
      color: var(--text-secondary);
    }

    .panel-insight strong {
      color: var(--text-primary);
      font-weight: 600;
    }

    .panel-insight .insight-label {
      display: inline-block;
      background: var(--accent-primary);
      color: white;
      font-size: 0.6875rem;
      font-weight: 600;
      padding: 0.125rem 0.5rem;
      border-radius: 4px;
      margin-bottom: 0.5rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    /* Cluster visualization */
    .cluster-legend {
      display: flex;
      gap: 1.5rem;
      padding: 0.75rem 1rem;
      background: var(--bg-secondary);
      border-radius: 8px;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }
    
    .cluster-legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
      color: var(--text-secondary);
    }
    
    .cluster-legend-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }
    
    #claim-clusters {
      min-height: 500px;
    }
    
    #claim-clusters svg {
      background: var(--bg-secondary);
      border-radius: 8px;
    }

    /* Panel-level time filter */
    .panel-time-filter {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      padding: 0.75rem 1rem;
      background: var(--bg-secondary);
      border-radius: 8px;
      margin-bottom: 1rem;
    }

    .panel-time-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .panel-time-filter label {
      font-size: 0.75rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      white-space: nowrap;
    }

    .panel-time-slider {
      width: 100%;
      height: 6px;
      -webkit-appearance: none;
      appearance: none;
      background: var(--bg-card);
      border-radius: 3px;
      outline: none;
      cursor: pointer;
    }

    .panel-time-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      background: var(--accent-primary);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(99, 102, 241, 0.4);
      transition: transform 0.15s ease;
    }

    .panel-time-slider::-webkit-slider-thumb:hover {
      transform: scale(1.15);
    }

    .panel-time-slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: var(--accent-primary);
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }

    .panel-time-value {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.875rem;
      color: var(--accent-primary);
      font-weight: 600;
    }

    .panel-time-ticks {
      display: flex;
      justify-content: space-between;
      font-size: 0.625rem;
      color: var(--text-muted);
      padding: 0 2px;
    }

    .panel-time-ticks span {
      text-align: center;
    }

    /* Network visualization */
    .network-container {
      position: relative;
      width: 100%;
      height: 450px;
    }

    .network-node {
      cursor: pointer;
      transition: opacity 0.2s ease;
    }

    .network-node:hover {
      opacity: 0.8;
    }

    .network-link {
      stroke-opacity: 0.4;
      transition: stroke-opacity 0.2s ease;
    }

    .network-link:hover {
      stroke-opacity: 0.8;
    }

    .network-label {
      font-family: 'IBM Plex Sans', sans-serif;
      font-size: 9px;
      fill: var(--text-secondary);
      pointer-events: none;
    }

    .network-legend {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
      margin-bottom: 0.75rem;
    }

    .network-legend-item {
      display: flex;
      align-items: center;
      gap: 0.375rem;
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .network-legend-circle {
      border-radius: 50%;
    }

    .network-legend-line {
      width: 20px;
      height: 2px;
    }

    .key-source {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 0.75rem 1rem;
      background: var(--bg-secondary);
      border-radius: 8px;
      transition: all 0.2s ease;
      color: inherit;
    }

    .key-source:hover {
      background: var(--bg-hover);
      transform: translateX(4px);
    }
    
    .key-source-clickable:hover {
      border-left: 3px solid var(--accent-primary);
      padding-left: calc(1rem - 3px);
    }
    
    .key-source-clickable[href="#"] {
      cursor: default;
    }

    .source-rank {
      font-family: 'IBM Plex Mono', monospace;
      font-weight: 700;
      font-size: 1.25rem;
      min-width: 2rem;
    }

    .source-bar {
      flex: 1;
      height: 24px;
      background: var(--bg-card);
      border-radius: 4px;
      overflow: hidden;
      position: relative;
    }

    .source-bar-fill {
      height: 100%;
      border-radius: 4px;
      transition: width 0.5s ease;
    }

    .source-bar-label {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 0.75rem;
      font-family: 'IBM Plex Mono', monospace;
      color: var(--text-primary);
    }

    .source-info {
      flex: 2;
      min-width: 0;
    }

    .source-title {
      font-size: 0.8125rem;
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .source-meta {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    /* Confidence Plot Styles */
    .confidence-plot {
      width: 100%;
      height: 100%;
    }

    .claim-bar {
      cursor: pointer;
      transition: opacity 0.2s ease;
    }

    .claim-bar:hover {
      opacity: 0.8;
    }

    .claim-label {
      font-family: 'IBM Plex Sans', sans-serif;
      font-size: 11px;
      fill: var(--text-secondary);
    }

    .reference-line {
      stroke: var(--text-muted);
      stroke-width: 1;
      stroke-dasharray: 4 4;
    }

    .axis-label {
      font-family: 'IBM Plex Sans', sans-serif;
      font-size: 12px;
      fill: var(--text-secondary);
    }

    /* Treemap Styles */
    .treemap-cell {
      cursor: pointer;
      transition: opacity 0.2s ease;
    }

    .treemap-cell:hover {
      opacity: 0.85;
    }

    .treemap-label {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 10px;
      fill: white;
      pointer-events: none;
    }

    /* Heatmap Styles */
    .heatmap-cell {
      cursor: pointer;
      transition: opacity 0.2s ease;
    }

    .heatmap-cell:hover {
      opacity: 0.8;
      stroke: white;
      stroke-width: 2;
    }

    /* Timeline Styles */
    .timeline-area {
      opacity: 0.7;
    }

    .timeline-line {
      fill: none;
      stroke-width: 2;
    }

    /* Tooltip */
    .tooltip {
      position: fixed;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.75rem 1rem;
      font-size: 0.8125rem;
      pointer-events: none;
      z-index: 1000;
      max-width: 350px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.4);
      opacity: 0;
      transition: opacity 0.15s ease;
    }

    .tooltip.visible {
      opacity: 1;
    }

    .tooltip-title {
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: var(--text-primary);
    }

    .tooltip-row {
      display: flex;
      justify-content: space-between;
      gap: 1rem;
      color: var(--text-secondary);
      margin-bottom: 0.25rem;
    }

    .tooltip-value {
      font-family: 'IBM Plex Mono', monospace;
      color: var(--text-primary);
    }

    /* Hypothesis Banner */
    .hypothesis-banner {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.15) 0%, rgba(139, 92, 246, 0.1) 100%);
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 12px;
      padding: 1.25rem 1.5rem;
      margin-bottom: 1.5rem;
    }

    .hypothesis-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.75rem;
    }

    .hypothesis-icon {
      font-size: 1.25rem;
    }

    .hypothesis-label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--accent-secondary);
      font-weight: 600;
    }

    .hypothesis-content {
      font-size: 1rem;
      line-height: 1.6;
      color: var(--text-primary);
    }

    .hypothesis-task {
      display: inline-block;
      padding: 0.125rem 0.5rem;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 600;
      margin-right: 0.5rem;
    }

    .legend {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
      padding: 0.75rem;
      background: var(--bg-secondary);
      border-radius: 8px;
      margin-bottom: 1rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8125rem;
      color: var(--text-secondary);
    }

    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 3px;
    }

    footer {
      text-align: center;
      padding: 2rem;
      color: var(--text-muted);
      font-size: 0.875rem;
      border-top: 1px solid var(--border);
      margin-top: 2rem;
    }

    footer a {
      color: var(--accent-primary);
      text-decoration: none;
    }

    footer a:hover {
      text-decoration: underline;
    }

    .generated-info {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.75rem;
      margin-top: 0.5rem;
    }
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <div class="logo">
        <div class="logo-icon">L</div>
        <div>
          <h1>Lyra Evidence Dashboard</h1>
          <div class="subtitle">Comparative Analysis: Insulin Add-on Therapies for T2DM</div>
        </div>
      </div>
      <nav class="task-toggle" id="task-toggle">
        <!-- Buttons generated dynamically from LYRA_DATA.tasks -->
      </nav>
    </div>
  </header>

  <main>
    <!-- Hypothesis Banner -->
    <section class="hypothesis-banner" id="hypothesis-banner">
      <div class="hypothesis-header">
        <span class="hypothesis-icon">üéØ</span>
        <span class="hypothesis-label">Research Hypothesis</span>
      </div>
      <div class="hypothesis-content" id="hypothesis-text">
        Loading hypothesis...
      </div>
    </section>

    <section class="summary-cards" id="summary-cards"></section>
    
    <!-- Metrics Definition -->
    <div class="metrics-definition" id="metrics-definition">
      <details open>
        <summary style="cursor:pointer;color:var(--accent-primary);font-size:0.85rem;margin-bottom:0.5rem;font-weight:600;">üìä Metric Definitions</summary>
        <div style="display:grid;grid-template-columns:repeat(2, 1fr);gap:1rem;padding:1rem;background:var(--bg-secondary);border-radius:8px;margin-top:0.5rem;">
          <div style="border-left:3px solid var(--accent-primary);padding-left:0.75rem;">
            <strong style="color:var(--text-primary);">Claims</strong>
            <p style="font-size:0.8rem;color:var(--text-muted);margin:0.25rem 0 0 0;">
              Atomic factual statements extracted from literature by LLM. Each claim represents a single verifiable assertion about the research hypothesis. Claims are the fundamental unit of evidence analysis.
            </p>
          </div>
          <div style="border-left:3px solid var(--accent-refute);padding-left:0.75rem;">
            <strong style="color:var(--accent-refute);">Contradictions</strong>
            <p style="font-size:0.8rem;color:var(--text-muted);margin:0.25rem 0 0 0;">
              Claims with ‚â•1 "refutes" evidence edge from NLI classification. Indicates areas of scientific disagreement. 
              <br><em>Controversy Score</em> = refute_count / (support_count + refute_count + 1). Range: 0‚Äì1.
            </p>
          </div>
          <div style="border-left:3px solid var(--accent-support);padding-left:0.75rem;">
            <strong style="color:var(--accent-support);">Bayesian Confidence</strong>
            <p style="font-size:0.8rem;color:var(--text-muted);margin:0.25rem 0 0 0;">
              Posterior probability from Bayesian updating. Prior=0.50 (neutral). Each NLI evidence edge updates the belief. 
              <br><strong>&gt;0.50</strong> = supports hypothesis | <strong>&lt;0.50</strong> = refutes | <strong>=0.50</strong> = neutral.
            </p>
          </div>
          <div style="border-left:3px solid var(--accent-secondary);padding-left:0.75rem;">
            <strong style="color:var(--accent-secondary);">Source Score</strong>
            <p style="font-size:0.8rem;color:var(--text-muted);margin:0.25rem 0 0 0;">
              Combined metric of source importance: claims_supported √ó (1 + log(citations + 1)). Higher scores indicate sources that provide more evidence for the hypothesis. Displayed in Key Supporting Sources.
            </p>
          </div>
        </div>
      </details>
    </div>
    
    <div class="dashboard-grid">
      <!-- 1. Evidence Timeline (TOP, no slider) -->
      <section class="panel panel-full">
        <div class="panel-header">
          <h2 class="panel-title">
            <span class="panel-title-icon" style="background: var(--gradient-3);">üìà</span>
            Evidence Timeline
          </h2>
        </div>
        <div class="panel-body" id="timeline"></div>
        <div class="panel-insight" id="timeline-insight">
          <span class="insight-label">Summary</span><br>
          Loading...
        </div>
      </section>

      <!-- 2. Key Supporting Sources (no slider) -->
      <section class="panel panel-full">
        <div class="panel-header">
          <h2 class="panel-title">
            <span class="panel-title-icon" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%);">üèÜ</span>
            Key Supporting Sources
          </h2>
        </div>
        <div class="panel-body" id="key-sources"></div>
        <div class="panel-insight" id="sources-insight">
          <span class="insight-label">Summary</span><br>
          Loading...
        </div>
      </section>

      <!-- 3. Evidence Citation Network (with time slider) -->
      <section class="panel panel-full">
        <div class="panel-header">
          <h2 class="panel-title">
            <span class="panel-title-icon" style="background: var(--gradient-1);">üï∏Ô∏è</span>
            Evidence Citation Network
          </h2>
        </div>
        <div class="panel-body">
          <div class="panel-time-filter">
            <div class="panel-time-header">
              <label>Time Filter</label>
              <span class="panel-time-value" id="network-year">All Years</span>
            </div>
            <input type="range" class="panel-time-slider" id="network-slider" min="2007" max="2028" step="3" value="2028">
            <div class="panel-time-ticks">
              <span>2007</span><span>2010</span><span>2013</span><span>2016</span><span>2019</span><span>2022</span><span>2025</span><span>All</span>
            </div>
          </div>
          <div class="network-legend">
            <div class="network-legend-item">
              <div style="width:14px;height:10px;background:#d97706;border-radius:2px"></div>
              DPP-4i Page
            </div>
            <div class="network-legend-item">
              <div style="width:14px;height:10px;background:#0891b2;border-radius:2px"></div>
              SGLT2i Page
            </div>
            <div class="network-legend-item">
              <svg width="12" height="12" viewBox="-6 -6 12 12"><polygon points="0,-5 5,0 0,5 -5,0" fill="#fbbf24"/></svg>
              Fragment
            </div>
            <div class="network-legend-item">
              <div class="network-legend-circle" style="width:12px;height:12px;background:var(--accent-dpp4i)"></div>
              DPP-4i Claim
            </div>
            <div class="network-legend-item">
              <div class="network-legend-circle" style="width:12px;height:12px;background:var(--accent-sglt2i)"></div>
              SGLT2i Claim
            </div>
            <div class="network-legend-item">
              <div class="network-legend-line" style="background:var(--accent-secondary)"></div>
              Cites (Page‚ÜíPage)
            </div>
            <div class="network-legend-item">
              <div class="network-legend-line" style="background:var(--text-muted)"></div>
              Contains
            </div>
          </div>
          <div class="network-container" id="evidence-network"></div>
        </div>
        <div class="panel-insight" id="network-insight">
          <span class="insight-label">Summary</span><br>
          Loading...
        </div>
      </section>

      <!-- 4. Controversy Evolution (no slider) -->
      <section class="panel">
        <div class="panel-header">
          <h2 class="panel-title">
            <span class="panel-title-icon" style="background: linear-gradient(135deg, #ef4444 0%, #f97316 100%);">‚ö°</span>
            Controversy Evolution
          </h2>
        </div>
        <div class="panel-body" id="controversy-timeline"></div>
        <div class="panel-insight" id="controversy-insight">
          <span class="insight-label">Summary</span><br>
          Loading...
        </div>
      </section>

      <!-- 5. Claim Similarity Clusters -->
      <section class="panel panel-full" id="cluster-section" style="display:none;">
        <div class="panel-header">
          <h2 class="panel-title">
            <span class="panel-title-icon" style="background: linear-gradient(135deg, #8b5cf6 0%, #ec4899 100%);">üîÆ</span>
            Claim Similarity Clusters
          </h2>
        </div>
        <div class="panel-body">
          <div class="cluster-legend" id="cluster-legend"></div>
          <div id="claim-clusters"></div>
        </div>
        <div class="panel-insight" id="cluster-insight">
          <span class="insight-label">Summary</span><br>
          Claims are positioned by semantic similarity using PCA dimensionality reduction.
          Clusters indicate groups of related claims across the evidence base.
        </div>
      </section>

      <!-- 6. Analysis Reports (tabbed) -->
      <section class="panel panel-full" id="analysis-section">
        <div class="panel-header" style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:0.5rem;">
          <h2 class="panel-title">
            <span class="panel-title-icon" style="background: linear-gradient(135deg, #10b981 0%, #3b82f6 100%);">üìÑ</span>
            Evidence Reports
          </h2>
          <div class="report-tabs" id="report-tabs"></div>
        </div>
        <div class="panel-body" id="analysis-results" style="min-height:auto;padding:1rem;max-height:600px;overflow-y:auto;">
          Loading reports...
        </div>
      </section>
    </div>
  </main>

  <footer>
    <p>Generated by <a href="https://github.com/your-repo/lyra">Lyra Evidence Graph System</a></p>
    <p class="generated-info">
      Tasks: task_ed3b72cf (DPP-4i) | task_8f90d8f6 (SGLT2i) | Generated: 2026-01-10
    </p>
  </footer>

  <div class="tooltip" id="tooltip"></div>

  <script>
    // =====================================================
    // EMBEDDED DATA FROM LYRA EVIDENCE GRAPH
    // =====================================================
    const LYRA_DATA = /* __LYRA_DATA__ */;

    // =====================================================
    // VISUALIZATION CODE
    // =====================================================
    
    let currentView = 'compare';
    const tooltip = d3.select('#tooltip');

    // Panel-specific time filters (stepped increments matching tick marks)
    const panelYears = {
      network: 2028   // 3-year steps: 2007, 2010, 2013, ..., 2025, 2028(All)
    };

    // Setup panel sliders
    function setupPanelSliders() {
      const panels = [
        { id: 'network', render: renderEvidenceNetwork, allValue: 2028 }
      ];

      panels.forEach(({ id, render, allValue }) => {
        const slider = document.getElementById(`${id}-slider`);
        const display = document.getElementById(`${id}-year`);
        
        slider.addEventListener('input', (e) => {
          panelYears[id] = parseInt(e.target.value);
          display.textContent = panelYears[id] >= allValue ? 'All Years' : `‚â§ ${panelYears[id]}`;
          render();
        });
      });
    }

    // Filter data by year for specific panel
    function filterByYear(data, yearKey = 'year', panelYear = 2028) {
      if (panelYear >= 2026) return data;  // Any "All" value
      return data.filter(d => !d[yearKey] || d[yearKey] <= panelYear);
    }

    // Format year for display
    function formatYear(year) {
      if (year >= 2026) return 'all time periods';
      return `${year}`;
    }

    function showTooltip(event, content) {
      const tooltipNode = tooltip.node();
      tooltip.html(content);
      
      // Get tooltip dimensions after content is set
      const tooltipRect = tooltipNode.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      
      // Calculate position - use clientX/clientY for fixed positioning
      let left = event.clientX + 15;
      let top = event.clientY - 10;
      
      // Prevent overflow on right edge
      if (left + tooltipRect.width > viewportWidth - 10) {
        left = event.clientX - tooltipRect.width - 15;
      }
      
      // Prevent overflow on bottom edge
      if (top + tooltipRect.height > viewportHeight - 10) {
        top = event.clientY - tooltipRect.height - 10;
      }
      
      // Prevent overflow on top edge
      if (top < 10) {
        top = 10;
      }
      
      tooltip
        .style('left', left + 'px')
        .style('top', top + 'px')
        .classed('visible', true);
    }

    function hideTooltip() {
      tooltip.classed('visible', false);
    }

    // Summary Cards - Task-centric layout with header grouping
    function renderSummaryCards() {
      const container = d3.select('#summary-cards');
      container.html('');
      
      // Change grid to side-by-side task blocks
      container.style('display', 'grid')
        .style('grid-template-columns', `repeat(${TASK_LIST.length}, 1fr)`)
        .style('gap', '1.5rem');

      // Create task-centric blocks
      TASK_LIST.forEach((tid, i) => {
        const task = LYRA_DATA.tasks[tid];
        const colorClass = i === 0 ? 'dpp4i' : (i === 1 ? 'sglt2i' : 'neutral');
        const borderColor = task.color || (i === 0 ? 'var(--accent-dpp4i)' : 'var(--accent-sglt2i)');
        
        const maxContro = task.contradictions.length > 0 
          ? d3.max(task.contradictions, d => d.controversy_score).toFixed(2) 
          : '0.00';
        const maxConf = task.claims.length > 0 
          ? d3.max(task.claims, d => d.bayesian_confidence).toFixed(2) 
          : '0.50';
        const avgConf = task.claims.length > 0 
          ? d3.mean(task.claims, d => d.bayesian_confidence).toFixed(2) 
          : '0.50';
        
        // Task block container
        const taskBlock = container.append('div')
          .style('background', 'var(--bg-card)')
          .style('border', '1px solid var(--border)')
          .style('border-left', `4px solid ${borderColor}`)
          .style('border-radius', '12px')
          .style('padding', '1rem')
          .style('transition', 'all 0.2s ease');
        
        // Task header
        taskBlock.append('div')
          .style('font-size', '1.1rem')
          .style('font-weight', '700')
          .style('color', borderColor)
          .style('margin-bottom', '0.75rem')
          .style('letter-spacing', '0.05em')
          .text(task.shortName);
        
        // Metrics row
        const metricsRow = taskBlock.append('div')
          .style('display', 'grid')
          .style('grid-template-columns', 'repeat(3, 1fr)')
          .style('gap', '0.75rem')
          .style('text-align', 'center');
        
        // Claims
        metricsRow.append('div')
          .html(`
            <div style="font-size:0.7rem;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.05em;">CLAIMS</div>
            <div style="font-family:'IBM Plex Mono',monospace;font-size:1.75rem;font-weight:600;color:${borderColor};">${task.stats.claims}</div>
            <div style="font-size:0.7rem;color:var(--text-secondary);">${task.stats.pages} pages</div>
          `);
        
        // Contradictions
        metricsRow.append('div')
          .html(`
            <div style="font-size:0.7rem;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.05em;">CONTRADICTIONS</div>
            <div style="font-family:'IBM Plex Mono',monospace;font-size:1.75rem;font-weight:600;color:var(--accent-refute);">${task.contradictions.length}</div>
            <div style="font-size:0.7rem;color:var(--text-secondary);">max ${maxContro}</div>
          `);
        
        // Top Confidence
        metricsRow.append('div')
          .html(`
            <div style="font-size:0.7rem;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.05em;">CONFIDENCE</div>
            <div style="font-family:'IBM Plex Mono',monospace;font-size:1.75rem;font-weight:600;color:var(--accent-support);">${maxConf}</div>
            <div style="font-size:0.7rem;color:var(--text-secondary);">avg ${avgConf}</div>
          `);
      });
    }

    // Evidence Citation Network (Page ‚Üí Fragment ‚Üí Claim hierarchy + citations)
    let networkSimulation = null;

    function renderEvidenceNetwork() {
      const container = d3.select('#evidence-network');
      container.html('');

      const width = container.node().clientWidth;
      const height = 480;
      const yearFilter = panelYears.network;
      const padding = 40;

      const svg = container.append('svg')
        .attr('width', width)
        .attr('height', height);

      let nodes = [];
      let links = [];
      const nodeMap = {};  // For looking up nodes by original ID

      // Build network from task data
      const buildNetworkData = (taskId, taskName, colors) => {
        const task = LYRA_DATA.tasks[taskId];
        const timeline = task.timeline;
        const maxYear = yearFilter >= 2026 ? 9999 : yearFilter;
        const availableYears = timeline.filter(t => t.year <= maxYear);
        
        if (availableYears.length === 0) return;
        
        const evidenceRatio = availableYears.length / timeline.length;

        // Add Pages (Sources)
        const pageCount = Math.max(3, Math.floor(task.sources.length * evidenceRatio * 0.6));
        const filteredPages = task.sources
          .filter(s => !s.year || s.year <= maxYear)
          .slice(0, pageCount);
        
        filteredPages.forEach(p => {
          const node = {
            id: `${taskId}_${p.id}`,
            origId: p.id,
            type: 'page',
            task: taskName,
            title: p.title || p.domain,
            domain: p.domain,
            authority: p.authority_score,
            url: p.url,
            color: colors.page
          };
          nodes.push(node);
          nodeMap[`${taskId}_${p.id}`] = node;
        });

        // Add Fragments
        const fragments = task.fragments || [];
        fragments.forEach(f => {
          const pageNode = nodeMap[`${taskId}_${f.page_id}`];
          if (!pageNode) return;
          
          const node = {
            id: `${taskId}_${f.id}`,
            origId: f.id,
            type: 'fragment',
            task: taskName,
            text: f.text,
            claimIds: f.claims,
            color: colors.fragment
          };
          nodes.push(node);
          nodeMap[`${taskId}_${f.id}`] = node;
          
          // Page ‚Üí Fragment link
          links.push({
            source: pageNode.id,
            target: node.id,
            type: 'contains',
            strength: 0.8
          });
        });

        // Add Claims (show more claims to represent the full 400+ claim dataset)
        const claimCount = Math.max(8, Math.floor(task.claims.length * evidenceRatio * 0.03));
        const filteredClaims = task.claims.slice(0, Math.min(claimCount, 12));
        
        filteredClaims.forEach(c => {
          const node = {
            id: `${taskId}_${c.id}`,
            origId: c.id,
            type: 'claim',
            task: taskName,
            text: c.text,
            confidence: c.bayesian_confidence,
            support: c.support,
            refute: c.refute,
            color: colors.claim
          };
          nodes.push(node);
          nodeMap[`${taskId}_${c.id}`] = node;
        });

        // Fragment ‚Üí Claim links
        fragments.forEach(f => {
          const fragNode = nodeMap[`${taskId}_${f.id}`];
          if (!fragNode) return;
          
          (f.claims || []).forEach(claimId => {
            const claimNode = nodeMap[`${taskId}_${claimId}`];
            if (claimNode) {
              links.push({
                source: fragNode.id,
                target: claimNode.id,
                type: 'extracts',
                strength: 0.6
              });
            }
          });
        });

        // Page ‚Üí Page citation links
        const citations = task.citations || [];
        citations.forEach(cit => {
          const fromNode = nodeMap[`${taskId}_${cit.from}`];
          const toNode = nodeMap[`${taskId}_${cit.to}`];
          if (fromNode && toNode) {
            links.push({
              source: fromNode.id,
              target: toNode.id,
              type: 'cites',
              context: cit.context,
              strength: 0.5
            });
          }
        });
      };

      // Build data for selected views
      // Build network data dynamically for each task
      TASK_LIST.forEach((tid, i) => {
        const task = LYRA_DATA.tasks[tid];
        const taskShortName = task.shortName.toLowerCase().replace(/-/g, '');
        
        if (currentView === 'compare' || currentView === taskShortName) {
          // Generate color variants for this task
          const baseColor = task.color;
          const colors = {
            page: d3.color(baseColor).darker(0.5).formatHex(),
            fragment: d3.color(baseColor).brighter(0.3).formatHex(),
            claim: baseColor
          };
          buildNetworkData(tid, task.shortName, colors);
        }
      });

      // Add cross-claim support relationships (same task only)
      const claims = nodes.filter(n => n.type === 'claim');
      claims.forEach((c1, i) => {
        claims.forEach((c2, j) => {
          if (i >= j || c1.task !== c2.task) return;
          if (Math.random() < 0.25) {
            links.push({
              source: c1.id,
              target: c2.id,
              type: 'supports',
              strength: Math.min(c1.confidence, c2.confidence) * 0.5
            });
          }
        });
      });

      if (nodes.length === 0) {
        svg.append('text')
          .attr('x', width / 2)
          .attr('y', height / 2)
          .attr('text-anchor', 'middle')
          .attr('fill', 'var(--text-muted)')
          .text('No evidence available for this time period');
        updateNetworkSummary([], [], [], yearFilter);
        return;
      }

      // Size scales (quadratic for clear differentiation)
      const claimSizeScale = d3.scalePow()
        .exponent(2)
        .domain([0.3, 0.8])
        .range([10, 35]);
      
      const pageSizeScale = d3.scalePow()
        .exponent(0.5)
        .domain([1, 100])
        .range([14, 30]);
      
      const fragmentSize = 7;

      const getNodeSize = (d) => {
        if (d.type === 'page') return pageSizeScale(d.authority);
        if (d.type === 'fragment') return fragmentSize;
        return claimSizeScale(d.confidence);
      };

      // Force simulation with boundary constraints
      if (networkSimulation) networkSimulation.stop();

      networkSimulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(d => {
          if (d.type === 'contains') return 30;
          if (d.type === 'extracts') return 40;
          if (d.type === 'cites') return 60;
          return 50;
        }).strength(d => d.strength * 0.5))
        .force('charge', d3.forceManyBody().strength(d => d.type === 'fragment' ? -30 : -80))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collision', d3.forceCollide().radius(d => getNodeSize(d) + 4))
        .force('boundaryX', d3.forceX(width / 2).strength(0.02))
        .force('boundaryY', d3.forceY(height / 2).strength(0.02));

      // Draw links with different styles
      const link = svg.append('g')
        .selectAll('line')
        .data(links)
        .enter()
        .append('line')
        .attr('class', 'network-link')
        .attr('stroke', d => {
          if (d.type === 'cites') return 'var(--accent-secondary)';
          if (d.type === 'contains') return 'var(--text-muted)';
          if (d.type === 'extracts') return 'var(--border)';
          if (d.type === 'supports') return 'var(--accent-support)';
          return 'var(--accent-refute)';
        })
        .attr('stroke-width', d => {
          if (d.type === 'cites') return 2;
          if (d.type === 'contains') return 1.5;
          if (d.type === 'extracts') return 1;
          return 1.5;
        })
        .attr('stroke-dasharray', d => {
          if (d.type === 'cites') return '6,3';
          if (d.type === 'extracts') return '2,2';
          return 'none';
        })
        .attr('stroke-opacity', d => d.type === 'extracts' ? 0.5 : 0.7);

      // Draw Page nodes (rounded rectangles)
      const pageNodes = nodes.filter(n => n.type === 'page');
      const pages = svg.append('g')
        .selectAll('rect')
        .data(pageNodes)
        .enter()
        .append('rect')
        .attr('class', 'network-node')
        .attr('width', d => pageSizeScale(d.authority) * 1.4)
        .attr('height', d => pageSizeScale(d.authority))
        .attr('rx', 3)
        .attr('fill', d => d.color)
        .attr('stroke', 'var(--bg-primary)')
        .attr('stroke-width', 2)
        .on('mouseover', (event, d) => {
          showTooltip(event, `
            <div class="tooltip-title">üìÑ ${d.title}</div>
            <div class="tooltip-row"><span>Type:</span><span class="tooltip-value">Page (Source)</span></div>
            <div class="tooltip-row"><span>Drug Class:</span><span class="tooltip-value">${d.task}</span></div>
            <div class="tooltip-row"><span>Score:</span><span class="tooltip-value">${d.authority.toFixed(0)}</span></div>
            <div class="tooltip-row"><span>Domain:</span><span class="tooltip-value">${d.domain}</span></div>
          `);
        })
        .on('mouseout', hideTooltip)
        .call(d3.drag().on('start', dragStarted).on('drag', dragged).on('end', dragEnded));

      // Draw Fragment nodes (small diamonds)
      const fragmentNodes = nodes.filter(n => n.type === 'fragment');
      const fragments = svg.append('g')
        .selectAll('polygon')
        .data(fragmentNodes)
        .enter()
        .append('polygon')
        .attr('class', 'network-node')
        .attr('points', d => {
          const s = fragmentSize;
          return `0,${-s} ${s},0 0,${s} ${-s},0`;
        })
        .attr('fill', d => d.color)
        .attr('stroke', 'var(--bg-secondary)')
        .attr('stroke-width', 1)
        .on('mouseover', (event, d) => {
          showTooltip(event, `
            <div class="tooltip-title">üìù Fragment</div>
            <div class="tooltip-row"><span>Text:</span><span class="tooltip-value">${d.text.slice(0, 60)}...</span></div>
            <div class="tooltip-row"><span>Drug Class:</span><span class="tooltip-value">${d.task}</span></div>
            <div class="tooltip-row"><span>Claims:</span><span class="tooltip-value">${d.claimIds?.length || 0}</span></div>
          `);
        })
        .on('mouseout', hideTooltip)
        .call(d3.drag().on('start', dragStarted).on('drag', dragged).on('end', dragEnded));

      // Draw Claim nodes (circles)
      const claimNodesData = nodes.filter(n => n.type === 'claim');
      const claimCircles = svg.append('g')
        .selectAll('circle')
        .data(claimNodesData)
        .enter()
        .append('circle')
        .attr('class', 'network-node')
        .attr('r', d => claimSizeScale(d.confidence))
        .attr('fill', d => d.color)
        .attr('stroke', d => d.confidence >= 0.65 ? 'white' : 'none')
        .attr('stroke-width', 2)
        .on('mouseover', (event, d) => {
          showTooltip(event, `
            <div class="tooltip-title">üí° Claim</div>
            <div class="tooltip-row"><span>Text:</span><span class="tooltip-value">${d.text.slice(0, 80)}...</span></div>
            <div class="tooltip-row"><span>Drug Class:</span><span class="tooltip-value">${d.task}</span></div>
            <div class="tooltip-row"><span>Confidence:</span><span class="tooltip-value">${d.confidence.toFixed(3)}</span></div>
            <div class="tooltip-row"><span>Support/Refute:</span><span class="tooltip-value">${d.support}/${d.refute}</span></div>
          `);
        })
        .on('mouseout', hideTooltip)
        .call(d3.drag().on('start', dragStarted).on('drag', dragged).on('end', dragEnded));

      function dragStarted(event, d) {
        if (!event.active) networkSimulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }
      function dragged(event, d) {
        d.fx = Math.max(padding, Math.min(width - padding, event.x));
        d.fy = Math.max(padding, Math.min(height - padding, event.y));
      }
      function dragEnded(event, d) {
        if (!event.active) networkSimulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      }

      // Constrain nodes to boundary on tick
      networkSimulation.on('tick', () => {
        // Constrain all nodes to boundary
        nodes.forEach(d => {
          const r = getNodeSize(d);
          d.x = Math.max(padding + r, Math.min(width - padding - r, d.x));
          d.y = Math.max(padding + r, Math.min(height - padding - r, d.y));
        });

        link
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);

        pages
          .attr('x', d => d.x - pageSizeScale(d.authority) * 0.7)
          .attr('y', d => d.y - pageSizeScale(d.authority) / 2);

        fragments
          .attr('transform', d => `translate(${d.x},${d.y})`);

        claimCircles
          .attr('cx', d => d.x)
          .attr('cy', d => d.y);
      });

      updateNetworkSummary(
        claimNodesData, 
        pageNodes, 
        fragmentNodes, 
        yearFilter
      );
    }

    function updateNetworkSummary(claims, pages, fragments, yearFilter) {
      const insightEl = document.getElementById('network-insight');
      
      if (claims.length === 0 && pages.length === 0) {
        insightEl.innerHTML = `<span class="insight-label">Summary</span><br>
          <strong>No evidence available</strong> for ‚â§${formatYear(yearFilter)}. Expand the time filter.`;
        return;
      }

      // Calculate per-task stats dynamically
      const taskStats = TASK_LIST.map(tid => {
        const task = LYRA_DATA.tasks[tid];
        const taskClaims = claims.filter(n => n.task === task.shortName);
        const taskPages = pages.filter(n => n.task === task.shortName);
        const taskFragments = fragments.filter(n => n.task === task.shortName);
        const avgConf = taskClaims.length > 0 ? d3.mean(taskClaims, n => n.confidence) : 0;
        
        return {
          name: task.shortName,
          color: task.color,
          claims: taskClaims.length,
          pages: taskPages.length,
          fragments: taskFragments.length,
          avgConf
        };
      });
      
      const highConfClaims = claims.filter(n => n.confidence >= 0.65);

      let summary = `<span class="insight-label">Summary</span><br>`;
      summary += `<strong>Evidence Graph (${formatYear(yearFilter)}):</strong> `;
      summary += `${pages.length} pages ‚Üí ${fragments.length} fragments ‚Üí ${claims.length} claims.<br><br>`;

      // Per-task breakdown
      summary += `<strong>Per Task:</strong><br>`;
      taskStats.forEach(s => {
        if (s.claims > 0 || s.pages > 0) {
          summary += `‚Ä¢ <span style="color:${s.color}">${s.name}</span>: ${s.pages} pages ‚Üí ${s.fragments} fragments ‚Üí ${s.claims} claims (avg: ${s.avgConf.toFixed(2)})<br>`;
        }
      });
      
      if (highConfClaims.length > 0) {
        summary += `<br><strong>High-Confidence:</strong> ${highConfClaims.length} claims ‚â•0.65 (white border)`;
      }
      
      summary += `<br><br><em style="color:var(--text-muted);font-size:0.8rem">‚ñ≠ Pages ¬∑ ‚óá Fragments ¬∑ ‚¨§ Claims | Purple dashed = citations | Gray = hierarchy</em>`;

      insightEl.innerHTML = summary;
    }

    // Claim Similarity Clusters (PCA 2D visualization)
    function renderClaimClusters() {
      const section = document.getElementById('cluster-section');
      const clusterData = LYRA_DATA.claim_clusters;
      
      // Handle both array format and object format with 'points' key
      const clusters = Array.isArray(clusterData) ? clusterData : (clusterData?.points || []);
      
      // Hide section if no cluster data
      if (!clusters || clusters.length === 0) {
        section.style.display = 'none';
        return;
      }
      section.style.display = 'block';
      
      const container = d3.select('#claim-clusters');
      container.html('');
      
      const legendContainer = d3.select('#cluster-legend');
      legendContainer.html('');
      
      const width = container.node().clientWidth;
      const height = 500;
      const margin = { top: 30, right: 30, bottom: 60, left: 70 };
      
      // Create legend
      TASK_LIST.forEach(tid => {
        const task = LYRA_DATA.tasks[tid];
        const taskClaims = clusters.filter(c => c.task_id === tid).length;
        legendContainer.append('div')
          .attr('class', 'cluster-legend-item')
          .html(`
            <span class="cluster-legend-dot" style="background:${task.color}"></span>
            <span>${task.shortName}: ${taskClaims} claims</span>
          `);
      });
      
      // Add confidence legend
      legendContainer.append('div')
        .attr('class', 'cluster-legend-item')
        .html(`
          <span style="width:12px;height:12px;border-radius:50%;border:2px solid white;display:inline-block;margin-right:0.5rem"></span>
          <span style="font-size:0.75rem;color:var(--text-muted)">High confidence (‚â•65%)</span>
        `);
      
      const svg = container.append('svg')
        .attr('width', width)
        .attr('height', height);
      
      const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);
      
      const innerWidth = width - margin.left - margin.right;
      const innerHeight = height - margin.top - margin.bottom;
      
      // Calculate data extent for PCA axes
      const xExtent = d3.extent(clusters, d => d.x);
      const yExtent = d3.extent(clusters, d => d.y);
      
      // Add padding to extent
      const xPadding = (xExtent[1] - xExtent[0]) * 0.05 || 5;
      const yPadding = (yExtent[1] - yExtent[0]) * 0.05 || 5;
      
      // X-axis: PCA Component 1
      const xScale = d3.scaleLinear()
        .domain([xExtent[0] - xPadding, xExtent[1] + xPadding])
        .range([0, innerWidth]);
      
      // Y-axis: PCA Component 2
      const yScale = d3.scaleLinear()
        .domain([yExtent[0] - yPadding, yExtent[1] + yPadding])
        .range([innerHeight, 0]);
      
      // Filter by current view
      let filteredClusters = clusters;
      if (currentView !== 'compare') {
        const taskId = TASK_LIST.find(tid => 
          LYRA_DATA.tasks[tid].shortName.toLowerCase().replace(/-/g, '') === currentView
        );
        if (taskId) {
          filteredClusters = clusters.filter(c => c.task_id === taskId);
        }
      }
      
      // Draw grid lines
      const xTicks = xScale.ticks(5);
      const yTicks = yScale.ticks(5);
      
      g.selectAll('.grid-x')
        .data(xTicks)
        .enter()
        .append('line')
        .attr('class', 'grid-x')
        .attr('x1', d => xScale(d))
        .attr('x2', d => xScale(d))
        .attr('y1', 0)
        .attr('y2', innerHeight)
        .attr('stroke', 'var(--border)')
        .attr('stroke-dasharray', '2,2')
        .attr('opacity', 0.5);
      
      g.selectAll('.grid-y')
        .data(yTicks)
        .enter()
        .append('line')
        .attr('class', 'grid-y')
        .attr('x1', 0)
        .attr('x2', innerWidth)
        .attr('y1', d => yScale(d))
        .attr('y2', d => yScale(d))
        .attr('stroke', 'var(--border)')
        .attr('stroke-dasharray', '2,2')
        .attr('opacity', 0.5);
      
      // Draw X axis
      g.append('g')
        .attr('transform', `translate(0,${innerHeight})`)
        .call(d3.axisBottom(xScale).ticks(5))
        .selectAll('text').attr('class', 'axis-label');
      
      g.append('text')
        .attr('x', innerWidth / 2)
        .attr('y', innerHeight + 45)
        .attr('text-anchor', 'middle')
        .attr('fill', 'var(--text-secondary)')
        .attr('font-size', '0.8rem')
        .text('PCA Component 1');
      
      // Draw Y axis
      g.append('g')
        .call(d3.axisLeft(yScale).ticks(5))
        .selectAll('text').attr('class', 'axis-label');
      
      g.append('text')
        .attr('transform', 'rotate(-90)')
        .attr('x', -innerHeight / 2)
        .attr('y', -50)
        .attr('text-anchor', 'middle')
        .attr('fill', 'var(--text-secondary)')
        .attr('font-size', '0.8rem')
        .text('PCA Component 2');
      
      // Draw nodes using PCA coordinates
      const nodes = g.selectAll('circle')
        .data(filteredClusters)
        .enter()
        .append('circle')
        .attr('cx', d => xScale(d.x))
        .attr('cy', d => yScale(d.y))
        .attr('r', 4)
        .attr('fill', d => {
          const task = LYRA_DATA.tasks[d.task_id];
          return task ? task.color : '#6366f1';
        })
        .attr('fill-opacity', 0.7)
        .attr('stroke', d => d.bayesian_confidence >= 0.65 ? 'white' : 'none')
        .attr('stroke-width', 1.5)
        .on('mouseover', (event, d) => {
          const task = LYRA_DATA.tasks[d.task_id];
          const confLabel = d.bayesian_confidence > 0.50 ? 'Supports' : (d.bayesian_confidence < 0.50 ? 'Refutes' : 'Neutral');
          const confColor = d.bayesian_confidence > 0.50 ? 'var(--accent-support)' : (d.bayesian_confidence < 0.50 ? 'var(--accent-refute)' : 'var(--text-muted)');
          showTooltip(event, `
            <div class="tooltip-title">${task ? task.shortName : 'Unknown'} Claim</div>
            <div class="tooltip-row"><span>PCA Position:</span><span class="tooltip-value">(${d.x.toFixed(1)}, ${d.y.toFixed(1)})</span></div>
            <div class="tooltip-row"><span>Confidence:</span><span class="tooltip-value">${(d.bayesian_confidence * 100).toFixed(0)}%</span></div>
            <div class="tooltip-row"><span>Direction:</span><span class="tooltip-value" style="color:${confColor}">${confLabel}</span></div>
            <div style="margin-top:0.5rem;font-size:0.75rem;color:var(--text-muted);max-width:300px;word-wrap:break-word;">
              ${d.text}...
            </div>
          `);
          d3.select(event.target).attr('fill-opacity', 1).attr('r', 6);
        })
        .on('mouseout', (event, d) => {
          hideTooltip();
          d3.select(event.target).attr('fill-opacity', 0.7).attr('r', 4);
        });
      
      // Update insight
      updateClusterInsight(filteredClusters);
    }
    
    function updateClusterInsight(clusters) {
      const insightEl = document.getElementById('cluster-insight');
      
      if (clusters.length === 0) {
        insightEl.innerHTML = `<span class="insight-label">Summary</span><br>No cluster data available.`;
        return;
      }
      
      const highConf = clusters.filter(c => c.bayesian_confidence >= 0.65).length;
      const supports = clusters.filter(c => c.bayesian_confidence > 0.50).length;
      const refutes = clusters.filter(c => c.bayesian_confidence < 0.50).length;
      
      // Calculate spread (variance indicator)
      const xMean = d3.mean(clusters, d => d.x);
      const yMean = d3.mean(clusters, d => d.y);
      const xVar = d3.variance(clusters, d => d.x) || 0;
      const yVar = d3.variance(clusters, d => d.y) || 0;
      const spreadScore = Math.sqrt(xVar + yVar).toFixed(1);
      
      let s = '<span class="insight-label">Summary</span><br>';
      s += `<strong>Claims:</strong> ${clusters.length} total | `;
      s += `<span style="color:var(--accent-support)">${supports}</span> supporting | `;
      s += `<span style="color:var(--accent-refute)">${refutes}</span> refuting | `;
      s += `<span style="color:white">${highConf}</span> high-confidence<br><br>`;
      s += `<strong>Semantic Spread:</strong> ${spreadScore} ‚Äî `;
      s += spreadScore > 20 ? 'Claims cover diverse topics' : 'Claims are semantically clustered';
      s += '<br><br>';
      s += '<em style="font-size:0.8rem;color:var(--text-muted)">PCA reduces 768-dimensional embeddings to 2D. Nearby points = semantically similar claims.</em>';
      
      insightEl.innerHTML = s;
    }

    // Controversy Evolution Timeline (line chart - per-year controversy)
    function renderControversyTimeline() {
      const container = d3.select('#controversy-timeline');
      container.html('');

      const margin = { top: 30, right: 120, bottom: 50, left: 60 };
      const width = container.node().clientWidth - margin.left - margin.right;
      const height = 320 - margin.top - margin.bottom;

      const svg = container.append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

      // Build controversy data dynamically from task list
      const task1 = TASK_LIST[0] ? LYRA_DATA.tasks[TASK_LIST[0]] : null;
      const task2 = TASK_LIST[1] ? LYRA_DATA.tasks[TASK_LIST[1]] : null;
      
      const dpp4iTimeline = task1 ? task1.timeline : [];
      const sglt2iTimeline = task2 ? task2.timeline : [];
      const dpp4iContros = task1 ? task1.contradictions : [];
      const sglt2iContros = task2 ? task2.contradictions : [];

      // Calculate per-year controversy scores (weighted by claims in that year)
      const totalDpp4iContro = d3.sum(dpp4iContros, d => d.controversy_score);
      const totalSglt2iContro = d3.sum(sglt2iContros, d => d.controversy_score);
      const totalDpp4iClaims = d3.sum(dpp4iTimeline, d => d.claims);
      const totalSglt2iClaims = d3.sum(sglt2iTimeline, d => d.claims);

      // Distribute controversy proportionally to claims per year
      let dpp4iData = [];
      let sglt2iData = [];

      dpp4iTimeline.forEach((t) => {
        const yearContro = totalDpp4iContro * (t.claims / totalDpp4iClaims);
        dpp4iData.push({ year: t.year, value: yearContro, claims: t.claims });
      });

      sglt2iTimeline.forEach((t) => {
        const yearContro = totalSglt2iContro * (t.claims / totalSglt2iClaims);
        sglt2iData.push({ year: t.year, value: yearContro, claims: t.claims });
      });

      // Filter based on view
      if (currentView === 'dpp4i') sglt2iData = [];
      if (currentView === 'sglt2i') dpp4iData = [];

      const allYears = [...new Set([...dpp4iData.map(d => d.year), ...sglt2iData.map(d => d.year)])].sort();
      const maxValue = Math.max(
        d3.max(dpp4iData, d => d.value) || 0,
        d3.max(sglt2iData, d => d.value) || 0
      );

      const x = d3.scaleLinear()
        .domain([d3.min(allYears), d3.max(allYears)])
        .range([0, width]);

      const y = d3.scaleLinear()
        .domain([0, maxValue * 1.1])
        .range([height, 0]);

      // Grid lines
      svg.append('g')
        .attr('class', 'grid')
        .selectAll('line')
        .data(y.ticks(5))
        .enter()
        .append('line')
        .attr('x1', 0)
        .attr('x2', width)
        .attr('y1', d => y(d))
        .attr('y2', d => y(d))
        .attr('stroke', 'var(--border)')
        .attr('stroke-dasharray', '2,2');

      // Axes
      svg.append('g')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x).tickFormat(d3.format('d')).ticks(8))
        .selectAll('text')
        .attr('class', 'axis-label');

      svg.append('g')
        .call(d3.axisLeft(y).ticks(5).tickFormat(d => d.toFixed(2)))
        .selectAll('text')
        .attr('class', 'axis-label');

      svg.append('text')
        .attr('transform', 'rotate(-90)')
        .attr('y', -45)
        .attr('x', -height / 2)
        .attr('text-anchor', 'middle')
        .attr('class', 'axis-label')
        .text('Controversy Score (per year)');

      // Line generator (linear for accurate year-to-year representation)
      const line = d3.line()
        .x(d => x(d.year))
        .y(d => y(d.value))
        .curve(d3.curveLinear);

      // DPP-4i line
      if (dpp4iData.length > 0) {
        svg.append('path')
          .datum(dpp4iData)
          .attr('fill', 'none')
          .attr('stroke', '#f59e0b')
          .attr('stroke-width', 2.5)
          .attr('stroke-dasharray', '8,4')
          .attr('d', line);

        svg.selectAll('.dot-dpp4i')
          .data(dpp4iData)
          .enter()
          .append('circle')
          .attr('cx', d => x(d.year))
          .attr('cy', d => y(d.value))
          .attr('r', 5)
          .attr('fill', '#f59e0b')
          .on('mouseover', (event, d) => {
            showTooltip(event, `
              <div class="tooltip-title">DPP-4i - ${d.year}</div>
              <div class="tooltip-row"><span>Controversy Score:</span><span class="tooltip-value">${d.value.toFixed(3)}</span></div>
              <div class="tooltip-row"><span>Claims:</span><span class="tooltip-value">${d.claims}</span></div>
            `);
          })
          .on('mouseout', hideTooltip);
      }

      // SGLT2i line
      if (sglt2iData.length > 0) {
        svg.append('path')
          .datum(sglt2iData)
          .attr('fill', 'none')
          .attr('stroke', '#06b6d4')
          .attr('stroke-width', 2.5)
          .attr('stroke-dasharray', '8,4')
          .attr('d', line);

        svg.selectAll('.dot-sglt2i')
          .data(sglt2iData)
          .enter()
          .append('circle')
          .attr('cx', d => x(d.year))
          .attr('cy', d => y(d.value))
          .attr('r', 5)
          .attr('fill', '#06b6d4')
          .on('mouseover', (event, d) => {
            showTooltip(event, `
              <div class="tooltip-title">SGLT2i - ${d.year}</div>
              <div class="tooltip-row"><span>Controversy Score:</span><span class="tooltip-value">${d.value.toFixed(3)}</span></div>
              <div class="tooltip-row"><span>Claims:</span><span class="tooltip-value">${d.claims}</span></div>
            `);
          })
          .on('mouseout', hideTooltip);
      }

      // Legend
      const legend = svg.append('g')
        .attr('transform', `translate(${width + 15}, 10)`);

      if (dpp4iData.length > 0) {
        legend.append('line').attr('x1', 0).attr('x2', 20).attr('y1', 0).attr('y2', 0)
          .attr('stroke', '#f59e0b').attr('stroke-width', 3);
        legend.append('text').attr('x', 25).attr('y', 4)
          .attr('class', 'axis-label').text('DPP-4i');
      }
      if (sglt2iData.length > 0) {
        legend.append('line').attr('x1', 0).attr('x2', 20).attr('y1', 25).attr('y2', 25)
          .attr('stroke', '#06b6d4').attr('stroke-width', 3);
        legend.append('text').attr('x', 25).attr('y', 29)
          .attr('class', 'axis-label').text('SGLT2i');
      }

      updateControversySummary();
    }

    function updateControversySummary() {
      const insightEl = document.getElementById('controversy-insight');
      
      // Collect controversy stats per task
      const taskStats = TASK_LIST.map(tid => {
        const task = LYRA_DATA.tasks[tid];
        const contros = task.contradictions || [];
        if (contros.length === 0) return null;
        
        const totalScore = d3.sum(contros, d => d.controversy_score);
        const top = contros.reduce((a, b) => a.controversy_score > b.controversy_score ? a : b);
        
        return {
          name: task.shortName,
          color: task.color,
          count: contros.length,
          totalScore,
          avgScore: totalScore / contros.length,
          topClaim: top.text.slice(0, 40),
          topScore: top.controversy_score
        };
      }).filter(Boolean);
      
      if (taskStats.length === 0) {
        insightEl.innerHTML = `<span class="insight-label">Summary</span><br>No controversy data available.`;
        return;
      }

      let summary = `<span class="insight-label">Summary</span><br>`;
      
      // Controversy count per task
      summary += `<strong>Controversial Claims:</strong> `;
      summary += taskStats.map(s => 
        `<span style="color:${s.color}">${s.name}</span>: ${s.count} (avg score: ${s.avgScore.toFixed(2)})`
      ).join(' | ');
      
      // Comparison if multiple tasks
      if (taskStats.length > 1) {
        const sorted = [...taskStats].sort((a, b) => b.totalScore - a.totalScore);
        const ratio = sorted[1].totalScore > 0 
          ? ((sorted[0].totalScore / sorted[1].totalScore - 1) * 100).toFixed(0)
          : 'N/A';
        if (ratio !== 'N/A' && ratio > 30) {
          summary += `<br><br><strong>Comparison:</strong> ${sorted[0].name} has ${ratio}% higher total controversy.`;
        }
      }
      
      summary += `<br><br><em style="color:var(--text-muted);font-size:0.8rem">Hover over data points to see key debates for each year.</em>`;
      
      insightEl.innerHTML = summary;
    }

    // Timeline
    function renderTimeline() {
      const container = d3.select('#timeline');
      container.html('');

      // Dynamic legend from task list
      const legend = container.append('div').attr('class', 'legend');
      TASK_LIST.forEach(tid => {
        const task = LYRA_DATA.tasks[tid];
        legend.append('div').attr('class', 'legend-item')
          .html(`<span class="legend-color" style="background:${task.color}"></span> ${task.shortName}`);
      });

      const margin = { top: 20, right: 30, bottom: 40, left: 60 };
      const width = container.node().clientWidth - margin.left - margin.right;
      const height = 300 - margin.top - margin.bottom;

      const svg = container.append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);

      // Collect timeline data from all tasks
      const taskTimelines = TASK_LIST.map(tid => ({
        id: tid,
        data: LYRA_DATA.tasks[tid].timeline,
        color: LYRA_DATA.tasks[tid].color,
        name: LYRA_DATA.tasks[tid].shortName
      }));
      
      // For backward compatibility, create dpp4iData and sglt2iData
      const dpp4iData = TASK_LIST[0] ? LYRA_DATA.tasks[TASK_LIST[0]].timeline : [];
      const sglt2iData = TASK_LIST[1] ? LYRA_DATA.tasks[TASK_LIST[1]].timeline : [];

      const allYears = [...new Set([...dpp4iData.map(d => d.year), ...sglt2iData.map(d => d.year)])].sort();
      const maxClaims = Math.max(
        d3.max(dpp4iData, d => d.claims),
        d3.max(sglt2iData, d => d.claims)
      );

      const x = d3.scaleLinear()
        .domain([d3.min(allYears), d3.max(allYears)])
        .range([0, width]);

      const y = d3.scaleLinear()
        .domain([0, maxClaims * 1.1])
        .range([height, 0]);

      // Axes
      svg.append('g')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(x).tickFormat(d3.format('d')))
        .selectAll('text')
        .attr('class', 'axis-label');

      svg.append('g')
        .call(d3.axisLeft(y).ticks(5))
        .selectAll('text')
        .attr('class', 'axis-label');

      svg.append('text')
        .attr('transform', 'rotate(-90)')
        .attr('y', -45)
        .attr('x', -height / 2)
        .attr('text-anchor', 'middle')
        .attr('class', 'axis-label')
        .text('Evidence Claims');

      // Area generators
      const area = d3.area()
        .x(d => x(d.year))
        .y0(height)
        .y1(d => y(d.claims))
        .curve(d3.curveMonotoneX);

      const line = d3.line()
        .x(d => x(d.year))
        .y(d => y(d.claims))
        .curve(d3.curveMonotoneX);

      // DPP-4i
      if (currentView === 'compare' || currentView === 'dpp4i') {
        svg.append('path')
          .datum(dpp4iData)
          .attr('class', 'timeline-area')
          .attr('fill', '#f59e0b')
          .attr('d', area);

        svg.append('path')
          .datum(dpp4iData)
          .attr('class', 'timeline-line')
          .attr('stroke', '#f59e0b')
          .attr('d', line);

        svg.selectAll('.dot-dpp4i')
          .data(dpp4iData)
          .enter()
          .append('circle')
          .attr('cx', d => x(d.year))
          .attr('cy', d => y(d.claims))
          .attr('r', 4)
          .attr('fill', '#f59e0b')
          .on('mouseover', (event, d) => {
            showTooltip(event, `
              <div class="tooltip-title">DPP-4i - ${d.year}</div>
              <div class="tooltip-row"><span>Claims:</span><span class="tooltip-value">${d.claims}</span></div>
              <div class="tooltip-row"><span>Fragments:</span><span class="tooltip-value">${d.fragments}</span></div>
            `);
          })
          .on('mouseout', hideTooltip);
      }

      // SGLT2i
      if (currentView === 'compare' || currentView === 'sglt2i') {
        svg.append('path')
          .datum(sglt2iData)
          .attr('class', 'timeline-area')
          .attr('fill', '#06b6d4')
          .attr('d', area);

        svg.append('path')
          .datum(sglt2iData)
          .attr('class', 'timeline-line')
          .attr('stroke', '#06b6d4')
          .attr('d', line);

        svg.selectAll('.dot-sglt2i')
          .data(sglt2iData)
          .enter()
          .append('circle')
          .attr('cx', d => x(d.year))
          .attr('cy', d => y(d.claims))
          .attr('r', 4)
          .attr('fill', '#06b6d4')
          .on('mouseover', (event, d) => {
            showTooltip(event, `
              <div class="tooltip-title">SGLT2i - ${d.year}</div>
              <div class="tooltip-row"><span>Claims:</span><span class="tooltip-value">${d.claims}</span></div>
              <div class="tooltip-row"><span>Fragments:</span><span class="tooltip-value">${d.fragments}</span></div>
            `);
          })
          .on('mouseout', hideTooltip);
      }

      // Generate summary
      updateTimelineSummary();
    }

    function updateTimelineSummary() {
      const insightEl = document.getElementById('timeline-insight');
      const currentYear = new Date().getFullYear();
      
      // Collect timeline stats per task
      const taskTimelineStats = TASK_LIST.map(tid => {
        const task = LYRA_DATA.tasks[tid];
        const timeline = task.timeline || [];
        if (timeline.length === 0) return null;
        
        const years = timeline.map(d => d.year);
        const startYear = Math.min(...years);
        const totalClaims = timeline.reduce((sum, d) => sum + d.claims, 0);
        const recentClaims = timeline.filter(d => d.year >= 2020).reduce((sum, d) => sum + d.claims, 0);
        const peak = timeline.reduce((max, d) => d.claims > max.claims ? d : max);
        
        return {
          name: task.shortName,
          color: task.color,
          startYear,
          span: currentYear - startYear,
          totalClaims,
          recentClaims,
          peakYear: peak.year,
          peakClaims: peak.claims
        };
      }).filter(Boolean);
      
      if (taskTimelineStats.length === 0) {
        insightEl.innerHTML = `<span class="insight-label">Summary</span><br>No timeline data available.`;
        return;
      }
      
      let summary = `<span class="insight-label">Summary</span><br>`;
      
      // Evidence maturity
      summary += `<strong>Evidence Maturity:</strong> `;
      summary += taskTimelineStats.map(s => 
        `<span style="color:${s.color}">${s.name}</span>: ${s.startYear}‚Äìpresent (${s.span} years)`
      ).join(' | ');
      
      // Recent activity comparison (if multiple tasks)
      if (taskTimelineStats.length > 1) {
        summary += `<br><br><strong>Recent Activity (2020+):</strong> `;
        const sortedByRecent = [...taskTimelineStats].sort((a, b) => b.recentClaims - a.recentClaims);
        const leader = sortedByRecent[0];
        const ratio = sortedByRecent[1].recentClaims > 0 
          ? ((leader.recentClaims / sortedByRecent[1].recentClaims - 1) * 100).toFixed(0)
          : 'N/A';
        summary += `${leader.name} leads with ${leader.recentClaims} claims`;
        if (ratio !== 'N/A' && ratio > 20) {
          summary += ` (${ratio}% more than ${sortedByRecent[1].name})`;
        }
      }
      
      // Peak years
      summary += `<br><br><strong>Peak Years:</strong> `;
      summary += taskTimelineStats.map(s => 
        `<span style="color:${s.color}">${s.name}</span>: ${s.peakYear} (${s.peakClaims} claims)`
      ).join(' | ');
      
      insightEl.innerHTML = summary;
    }

    // Key Supporting Sources
    function renderKeySources() {
      const container = d3.select('#key-sources');
      container.html('');

      // Combine and rank sources by authority score (no time filter for Key Sources)
      let allSources = [];
      
      TASK_LIST.forEach(tid => {
        const task = LYRA_DATA.tasks[tid];
        const taskShortName = task.shortName.toLowerCase().replace(/-/g, '');
        
        if (currentView === 'compare' || currentView === taskShortName) {
          task.sources.forEach(s => {
            allSources.push({ ...s, task: task.shortName, color: task.color });
          });
        }
      });

      allSources.sort((a, b) => b.authority_score - a.authority_score);
      const topSources = allSources.slice(0, 10);
      const maxScore = topSources.length > 0 ? topSources[0].authority_score : 1;

      // Single column layout with overflow protection
      const wrapper = container.append('div')
        .style('display', 'flex')
        .style('flex-direction', 'column')
        .style('gap', '0.5rem')
        .style('max-height', '360px')
        .style('overflow-y', 'auto');

      topSources.forEach((source, i) => {
        const hasUrl = source.url && source.url !== '#' && source.url !== '';
        
        const card = wrapper.append('a')
          .attr('class', 'key-source key-source-clickable')
          .attr('href', hasUrl ? source.url : null)
          .attr('target', hasUrl ? '_blank' : null)
          .attr('rel', hasUrl ? 'noopener noreferrer' : null)
          .style('text-decoration', 'none')
          .style('cursor', hasUrl ? 'pointer' : 'default')
          .on('click', (event) => {
            if (hasUrl) {
              // Allow default link behavior
            } else {
              event.preventDefault();
            }
          })
          .on('mouseover', (event) => {
            showTooltip(event, `
              <div class="tooltip-title">${source.title || source.domain}</div>
              <div class="tooltip-row"><span>Score:</span><span class="tooltip-value">${source.authority_score.toFixed(1)}</span></div>
              <div class="tooltip-row"><span>Claims Supported:</span><span class="tooltip-value">${source.claims_supported}</span></div>
              <div class="tooltip-row"><span>Year:</span><span class="tooltip-value">${source.year || 'N/A'}</span></div>
              <div class="tooltip-row"><span>Drug Class:</span><span class="tooltip-value">${source.task}</span></div>
              ${hasUrl ? `<div style="margin-top:0.5rem;font-size:0.7rem;color:var(--accent-primary)">üîó Click to open source</div>` : '<div style="margin-top:0.5rem;font-size:0.7rem;color:var(--text-muted)">No URL available</div>'}
            `);
          })
          .on('mouseout', hideTooltip);

        card.append('div')
          .attr('class', 'source-rank')
          .style('color', source.color)
          .style('min-width', '2.5rem')
          .text(`#${i + 1}`);

        const info = card.append('div')
          .attr('class', 'source-info')
          .style('flex', '1')
          .style('min-width', '0')
          .style('overflow', 'hidden');
        
        info.append('div')
          .attr('class', 'source-title')
          .style('white-space', 'nowrap')
          .style('overflow', 'hidden')
          .style('text-overflow', 'ellipsis')
          .text(source.title || source.domain);
        
        info.append('div')
          .attr('class', 'source-meta')
          .style('white-space', 'nowrap')
          .style('overflow', 'hidden')
          .style('text-overflow', 'ellipsis')
          .html(`<span style="color:${source.color}">${source.task}</span> ¬∑ ${source.domain} ${source.year ? `¬∑ ${source.year}` : ''} ${hasUrl ? 'üîó' : ''}`);

        const barContainer = card.append('div')
          .attr('class', 'source-bar')
          .style('width', '100px')
          .style('flex-shrink', '0');
        
        barContainer.append('div')
          .attr('class', 'source-bar-fill')
          .style('width', `${(source.authority_score / maxScore) * 100}%`)
          .style('background', source.color);
      });

      // Update summary
      updateSourcesSummary(topSources, allSources);
    }

    function updateSourcesSummary(topSources, allSources) {
      const insightEl = document.getElementById('sources-insight');
      
      if (topSources.length === 0) {
        insightEl.innerHTML = `<span class="insight-label">Summary</span><br>No sources available.`;
        return;
      }

      // Calculate stats dynamically per task
      const taskStats = {};
      TASK_LIST.forEach(tid => {
        const task = LYRA_DATA.tasks[tid];
        const taskSources = allSources.filter(s => s.task === task.shortName);
        const topTaskSources = topSources.filter(s => s.task === task.shortName);
        taskStats[task.shortName] = {
          total: taskSources.length,
          inTop: topTaskSources.length,
          totalScore: taskSources.reduce((sum, s) => sum + s.authority_score, 0),
          avgScore: taskSources.length > 0 ? taskSources.reduce((sum, s) => sum + s.authority_score, 0) / taskSources.length : 0,
          color: task.color
        };
      });
      
      // Detect meta-analyses/systematic reviews
      const metaAnalyses = topSources.filter(s => 
        s.title && (s.title.toLowerCase().includes('meta') || s.title.toLowerCase().includes('systematic'))
      );
      
      // Calculate year distribution
      const yearsWithData = allSources.filter(s => s.year).map(s => s.year);
      const yearRange = yearsWithData.length > 0 
        ? { min: Math.min(...yearsWithData), max: Math.max(...yearsWithData) }
        : null;
      
      // Build summary
      let summary = `<span class="insight-label">Summary</span><br>`;
      
      // Source count per task
      const taskNames = Object.keys(taskStats);
      const statsText = taskNames.map(name => {
        const s = taskStats[name];
        return `<span style="color:${s.color}">${name}</span>: ${s.total} sources (avg score: ${s.avgScore.toFixed(1)})`;
      }).join(' | ');
      summary += `<strong>Sources:</strong> ${statsText}<br><br>`;
      
      // Year range
      if (yearRange) {
        summary += `<strong>Publication Range:</strong> ${yearRange.min}‚Äì${yearRange.max}<br><br>`;
      }
      
      // Score definition
      summary += `<em style="color:var(--text-muted);font-size:0.8rem">üìä Score = claims supported by this source in the Evidence Graph.</em>`;
      
      insightEl.innerHTML = summary;
    }

    // Event Handlers
    function switchView(view) {
      currentView = view;
      document.querySelectorAll('.task-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.task === view);
      });
      renderAll();
    }

    // Get task list dynamically
    const TASK_LIST = Object.keys(LYRA_DATA.tasks);
    const TASK_COUNT = TASK_LIST.length;

    // Utility: hex color to rgba
    function hexToRgba(hex, alpha = 1) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r},${g},${b},${alpha})`;
    }

    // Initialize task toggle buttons dynamically
    function initTaskToggle() {
      const nav = document.getElementById('task-toggle');
      
      // Add individual task buttons
      TASK_LIST.forEach(tid => {
        const task = LYRA_DATA.tasks[tid];
        const btn = document.createElement('button');
        btn.className = 'task-btn';
        btn.dataset.task = task.shortName.toLowerCase().replace(/-/g, '');
        btn.textContent = task.shortName;
        btn.addEventListener('click', () => switchView(btn.dataset.task));
        nav.appendChild(btn);
      });
      
      // Add Compare button if multiple tasks
      if (TASK_COUNT > 1) {
        const compareBtn = document.createElement('button');
        compareBtn.className = 'task-btn active';
        compareBtn.dataset.task = 'compare';
        compareBtn.textContent = 'Compare';
        compareBtn.addEventListener('click', () => switchView('compare'));
        nav.appendChild(compareBtn);
      } else if (TASK_COUNT === 1) {
        // Single task: activate its button
        nav.querySelector('.task-btn').classList.add('active');
        currentView = nav.querySelector('.task-btn').dataset.task;
      }
    }

    function renderHypothesis() {
      const container = document.getElementById('hypothesis-text');
      
      if (currentView === 'compare') {
        // Show all tasks' hypotheses
        container.innerHTML = TASK_LIST.map(tid => {
          const task = LYRA_DATA.tasks[tid];
          const colorHex = task.color;
          const colorRgba = hexToRgba(colorHex, 0.2);
          return `
            <div style="margin-bottom:0.75rem">
              <span class="hypothesis-task" style="background:${colorRgba};color:${colorHex}">${task.shortName}</span>
              ${task.hypothesis}
            </div>
          `;
        }).join('');
      } else {
        // Find task by shortName match
        const taskId = TASK_LIST.find(tid => LYRA_DATA.tasks[tid].shortName.toLowerCase().replace(/-/g, '') === currentView);
        if (!taskId) return;
        const task = LYRA_DATA.tasks[taskId];
        const colorRgba = hexToRgba(task.color, 0.2);
        container.innerHTML = `
          <span class="hypothesis-task" style="background:${colorRgba};color:${task.color}">${task.shortName}</span>
          ${task.hypothesis}
        `;
      }
    }

    // Evidence Reports with tabs (imported from report.md)
    let activeReportTab = null;
    
    function renderAnalysis() {
      const container = document.getElementById('analysis-results');
      const tabsContainer = document.getElementById('report-tabs');
      const reports = LYRA_DATA.reports || {};
      
      // Check if we have any imported reports
      const hasReports = Object.keys(reports).length > 0;
      
      if (!hasReports) {
        tabsContainer.innerHTML = '';
        container.innerHTML = '<p style="color:var(--text-muted);text-align:center;padding:2rem;">No reports available. Use --tasks task_id:report.md to import reports.</p>';
        return;
      }
      
      // Build tabs
      let tabsHtml = '';
      TASK_LIST.forEach((tid, idx) => {
        if (!reports[tid]) return;
        const task = LYRA_DATA.tasks[tid];
        const isActive = activeReportTab === tid || (!activeReportTab && idx === 0);
        if (!activeReportTab && idx === 0) activeReportTab = tid;
        
        tabsHtml += `
          <button class="report-tab ${isActive ? 'active' : ''}" 
                  data-task="${tid}"
                  style="padding:0.4rem 1rem;border:none;border-radius:6px;cursor:pointer;
                         font-family:inherit;font-size:0.8rem;font-weight:500;
                         transition:all 0.2s ease;
                         background:${isActive ? task.color : 'var(--bg-card)'};
                         color:${isActive ? 'white' : 'var(--text-secondary)'};">
            ${task.shortName}
          </button>
        `;
      });
      tabsContainer.innerHTML = tabsHtml;
      
      // Add tab click handlers
      tabsContainer.querySelectorAll('.report-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          activeReportTab = tab.dataset.task;
          renderAnalysis();
        });
      });
      
      // Render active report
      const activeTask = LYRA_DATA.tasks[activeReportTab];
      const activeReportHtml = reports[activeReportTab];
      
      container.innerHTML = `
        <div style="border-left:4px solid ${activeTask.color};padding-left:1rem;">
          ${activeReportHtml}
        </div>
      `;
    }

    function renderAll() {
      renderHypothesis();
      renderSummaryCards();
      renderTimeline();
      renderKeySources();
      renderEvidenceNetwork();
      renderControversyTimeline();
      renderClaimClusters();
      renderAnalysis();
    }

    // Initialize
    initTaskToggle();
    
    window.addEventListener('resize', () => {
      renderAll();
    });

    setupPanelSliders();
    renderAll();
  </script>
</body>
</html>
