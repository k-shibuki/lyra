---
description: General debugging conventions
alwaysApply: false
---
# Debugging Conventions

## Positioning (Separation of Policy and Procedure)

- This file defines **policies (principles and constraints)**.
- Specific procedures (checklists, commands, query collections) are documented in `@.cursor/commands/debug.md`.

## Purpose

Achieve reproducible and efficient problem resolution. This project heavily uses **E2E debugging** due to MCP server characteristics (state persistence, async pipelines, multi-component interactions).

### Debug Method Priority

1. **Python scripts** (`debug/scripts/`) - Isolated, reproducible, no user interaction
2. **MCP tools** (`query_sql`, etc.) - When DB state inspection needed during MCP session
3. **User operations** - Only when unavoidable (MCP restart, browser auth)

---

## 0. Task Prefix Convention (Multi-Agent Support)

**Multiple AI agents may debug concurrently.** Use consistent prefixes across all artifacts to avoid conflicts:

| Artifact | Pattern | Example |
|----------|---------|---------|
| Docs | `debug/docs/<TASK>_report.md` | `debug/docs/BUDGET_report.md` |
| Logs | `debug/scripts/<TASK>_debug.log` | `debug/scripts/BUDGET_debug.log` |
| Hypothesis IDs | `<TASK>-H1`, `<TASK>-H2`, ... | `BUDGET-H1`, `NLI-H2` |

### Common Task Prefixes

`BUDGET`, `NLI`, `SERP`, `API`, `FETCH`, `EXTRACT`, `QUEUE`

---

## 1. Basic Debugging Principles

### 1.1 Autonomous Execution Principle

- **AI executes autonomously**: AI directly executes terminal commands, test scripts, and DB queries without asking user to perform operations
  - Exception: MCP server restart/reconnection requires user operation
  - If MCP tool returns `Tool not found`, request reconnection
- **Don't fix based on speculation**: Fix based on evidence from logs or instrumentation

### 1.2 Timeout Required

Terminal commands **must always have timeout set** to prevent hangs:

```bash
# Good: with timeout
timeout 30 uv run python -c "..."

# Bad: no timeout (hang risk)
uv run python -c "..."
```

**Recommended Timeout Values**:

| Operation | Timeout |
|-----------|---------|
| Environment check (make doctor, etc.) | 30s |
| DB operations/queries | 10s |
| MCP handler test | 30s |
| Search execution (queue_searches) | 120s |
| Page fetch/extraction | 60s |

### 1.3 Log Verification

**MCP Server logs** (`logs/lyra_YYYYMMDD.log`):

```bash
make mcp-logs                        # Show last 100 lines
make mcp-logs-f                      # Follow in real-time
make mcp-logs-grep PATTERN="error"   # Pattern search
```

**Container logs** (proxy/ollama/ml/tor):

```bash
make logs SERVICE=proxy              # Specific service
make logs-f SERVICE=ollama           # Follow specific service
```

### 1.4 Hypothesis → Instrumentation → Verification Cycle

1. **Hypothesis Formation**: List possible causes from symptoms (use `<TASK>-H1`, `<TASK>-H2`, ...)
2. **Instrumentation**: Add logs/assertions that can verify hypotheses
3. **Verification**: Reject or adopt hypotheses based on instrumentation results
4. **Iteration**: If hypothesis is rejected, move to next hypothesis

---

## 2. Instrumentation Guidelines

### 2.1 Philosophy

**No limit on instrumentation count.** Add as many logs as needed to:
- Track value propagation across function boundaries
- Identify exact point of divergence (expected vs actual)
- Debug in **minimum steps** (one reproduction run should provide enough data)

### 2.2 Log File Location

`debug/scripts/<TASK>_debug.log` (NDJSON format)

**PROHIBITED**: `.cursor/debug.log` (system-protected)

### 2.3 Log Clearing

```bash
echo "" > debug/scripts/<TASK>_debug.log   # Empty overwrite (no user prompt)
```

### 2.4 Instrumentation Template

```python
# #region agent log
import json, time
with open("debug/scripts/<TASK>_debug.log", "a") as f:
    f.write(json.dumps({
        "hypothesisId": "<TASK>-H1",
        "location": "src/xxx.py:func_name",
        "message": "desc",
        "data": {"key": "value"},
        "timestamp": time.time() * 1000
    }) + "\n")
# #endregion
```

### 2.5 Placement Strategy (Propagation Tracking)

For debugging value propagation issues:

```
[Entry point] → [Transform 1] → [Transform 2] → [Exit point]
     ↓               ↓               ↓               ↓
   H1-L1           H1-L2           H1-L3           H1-L4
```

| Location | What to log |
|----------|-------------|
| Entry point | Raw input values |
| Each transform | Before/after values, which branch taken |
| Exit point | Final output values |
| Error handlers | Exception type, message, context |

### 2.6 Hypothesis ID Convention

- `<TASK>-H1`, `<TASK>-H2`, ... : Main hypotheses
- `<TASK>-H1a`, `<TASK>-H1b`, ... : Sub-hypotheses
- Use same hypothesis ID for all logs tracing one propagation path

---

## 3. State-Based Debugging Principles

### 3.1 Define Expected State First

Before bug investigation, clarify "normal DB/queue/cache state":

1. **Reference ADR/Schema**: Check state transitions and constraints
2. **Verbalize Expected State**: Define "what should have happened" first
3. **Compare with Actual State**: Identify cause from differences

### 3.2 State Transition Verification Patterns

| Verification Target | Check Items |
|--------------------|-------------|
| Record lifecycle | Is transition created → active → completed/cancelled correct? |
| Foreign key integrity | Are child records orphaned when parent record is deleted? |
| Timestamps | Is created_at < updated_at < expires_at order correct? |
| Status transitions | Are there disallowed transitions (cancelled → active, etc.)? |

### 3.3 Inconsistency Detection Approaches

1. **Direct query**: `SELECT ... WHERE status NOT IN ('expected', 'values')`
2. **Count comparison**: Compare expected vs actual record counts between related tables
3. **Logical contradiction detection**: Search for logically impossible states like `expires_at < created_at`

---

## 4. Handling DB Lock Contention

### 4.1 Problem Recognition

When MCP server holds DB write lock (WAL WRITER lock), writes from other processes will hang.

**Verification method**:
```bash
fuser data/lyra.db  # Check processes using DB
```

### 4.2 Workarounds

| Scenario | Solution |
|----------|----------|
| E2E scenario execution | Call tools via MCP server (normal route, no problem) |
| Direct testing | Use isolated test DB (`test_database` fixture in `tests/conftest.py`) |
| Emergency | Test after MCP server restart (requires user operation) |

---

## 5. Checklists

### Before Starting Debug

- [ ] Accurately described symptoms (expected vs actual)
- [ ] Defined expected DB state
- [ ] Listed hypotheses with task prefix (`<TASK>-H1`, ...)

### During Debug

- [ ] Added timeout to terminal commands
- [ ] Added region markers to instrumentation (`#region agent log`)
- [ ] Included hypothesis ID with task prefix in logs

### After Debug Completion

- [ ] Removed instrumentation code
- [ ] Identified root cause and made minimal fix
- [ ] Verified fix with tests
- [ ] Created report at `debug/docs/<TASK>_report.md` (if significant)

---

## 6. Python-Specific Pitfalls

### 6.1 `dict.get(key, default)` and `None` Values

**Problem**: `dict.get(key, default)` returns `None`, not `default`, when key exists with `None` value.

```python
# NG: When API response is {"externalIds": null}, returns None
external_ids = data.get("externalIds", {})  # → None

# OK: Use or pattern to convert None to empty dict
external_ids = data.get("externalIds") or {}  # → {}
```

**When to apply**:
- JSON parsing from external APIs
- Dictionary retrieval where value can be `None`

### 6.2 Exception Type Matching

**Problem**: Custom exception classes and external library exception classes are different.

```python
# NG: Cannot catch httpx.HTTPStatusError
from src.utils.api_retry import HTTPStatusError  # custom
except HTTPStatusError as e:  # httpx exception passes through

# OK: Catch both
import httpx
except httpx.HTTPStatusError as e:  # httpx exception
    ...
except HTTPStatusError as e:  # custom exception
    ...
```

**Verification method**: Check exception types thrown by `raise_for_status()` etc. in documentation.

### 6.3 Rate Limiter Application Scope

**Principle**: Apply Rate Limiter to all external call methods in API clients.

```python
# NG: Applied only to search()
async def search(self, query: str) -> list[Paper]:
    await limiter.acquire(self.name)
    ...

async def get_references(self, paper_id: str) -> list[Paper]:
    # No Rate Limiter → 429 on bulk requests
    ...

# OK: Applied to all methods
async def get_references(self, paper_id: str) -> list[Paper]:
    await limiter.acquire(self.name)
    try:
        ...
    finally:
        limiter.release(self.name)
```
