---
alwaysApply: true
---
# E2Eデバッグ規約

## 位置づけ（規約と手順の分離）

- 本ファイルは **規約（原則・制約）** を定義する。
- 具体的な手順（チェックリスト・コマンド・クエリ集）は `@.cursor/commands/debug-e2e.md` を参照する。

## 目的

E2Eシナリオ（`docs/S_FULL_E2E.md` 等）を完遂するためのデバッグにおいて、再現性があり効率的な問題解決を行う。

---

## 0. デバッグ基本原則

### 0.1 自律実行の原則

- **AIが自律的に実行**: ユーザーに操作を依頼せず、AIがターミナルコマンド・テストスクリプト・DBクエリを直接実行する
  - 例外: MCPサーバの再起動・再接続はユーザー操作が必要
  - MCPツールが `Tool not found` になった場合は再接続を依頼する
- **推測で修正しない**: ログや計装による証拠に基づいて修正する

### 0.2 タイムアウト必須

ターミナルコマンドは **必ずタイムアウトを設定** してハングを防ぐ:

```bash
# 良い例: timeout付き
timeout 30 uv run python -c "..."

# 悪い例: タイムアウトなし（ハングの危険）
uv run python -c "..."
```

**推奨タイムアウト値**:

| 操作 | タイムアウト |
|------|-------------|
| 環境チェック（make doctor等） | 30秒 |
| DB操作・クエリ | 10秒 |
| MCP ハンドラーテスト | 30秒 |
| 検索実行（queue_searches） | 120秒 |
| ページ取得・抽出 | 60秒 |

### 0.3 仮説→計装→検証サイクル

1. **仮説形成**: 症状から原因候補を列挙する
2. **計装**: 仮説を検証できるログ/アサーションを追加する
3. **検証**: 計装結果から仮説を棄却または採用する
4. **反復**: 仮説が棄却されたら次の仮説へ

---

## 1. 計装の指針

### 1.1 ログ形式（NDJSON）

デバッグログはNDJSON形式で `/home/statuser/lyra/.cursor/debug.log` に出力:

```python
# #region agent log
import json
with open("/home/statuser/lyra/.cursor/debug.log", "a") as f:
    f.write(json.dumps({
        "location": "src/xxx.py:LINE",
        "message": "desc",
        "data": {"key": "value"},
        "timestamp": __import__("time").time() * 1000,
        "sessionId": "debug-session",
        "hypothesisId": "A"
    }) + "\n")
# #endregion
```

### 1.2 計装の配置ルール

| 配置箇所 | 記録内容 |
|----------|----------|
| 関数エントリ | 引数の値 |
| 関数イグジット | 戻り値 |
| 分岐ポイント | どのブランチが実行されたか |
| 外部呼び出し前後 | API/DB呼び出しの入出力 |
| 例外キャッチ | 例外の型とメッセージ |

### 1.3 仮説IDの命名規約

- `A`, `B`, `C`, ... : 主仮説
- `A1`, `A2`, ... : サブ仮説
- 各ログに `hypothesisId` を付与し、分析時に絞り込めるようにする

---

## 2. 状態ベースデバッグの原則

### 2.1 期待状態を先に定義する

バグ調査の前に「正常時のDB/キュー/キャッシュの状態」を明確にする:

1. **ADR/スキーマ参照**: 状態遷移や制約を確認する
2. **期待状態の言語化**: 「何が起きるべきだったか」を先に定義する
3. **実際状態との比較**: 差分から原因を特定する

### 2.2 状態遷移の検証パターン

| 検証対象 | 確認項目 |
|----------|----------|
| レコードのライフサイクル | created → active → completed/cancelled の遷移が正しいか |
| 外部キー整合性 | 親レコード削除時に子レコードが孤立していないか |
| タイムスタンプ | created_at < updated_at < expires_at の順序が正しいか |
| ステータス遷移 | 許可されていない遷移（cancelled → active 等）がないか |

### 2.3 不整合検出のアプローチ

1. **直接クエリ**: `SELECT ... WHERE status NOT IN ('expected', 'values')`
2. **カウント比較**: 関連テーブル間のレコード数の期待値と実際値を比較
3. **論理的矛盾検出**: `expires_at < created_at` のような論理的に不可能な状態を検索

---

## 3. DBロック競合への対処

### 3.1 問題の認識

MCPサーバがDB書き込みロック（WAL WRITER lock）を保持している場合、別プロセスからの書き込みがハングする。

**確認方法**:
```bash
fuser data/lyra.db  # DBを使用しているプロセスを確認
```

### 3.2 回避策

| シナリオ | 対処 |
|----------|------|
| E2Eシナリオ実行 | MCPサーバ経由でツールを呼び出す（正規ルート、問題なし） |
| 直接テスト | テスト用隔離DB（`tests/conftest.py` の `test_database` fixture）を使用 |
| 緊急時 | MCPサーバ再起動後にテスト（ユーザー操作必要） |

---

## 4. チェックリスト

### デバッグ開始前

- [ ] 症状を正確に記述した（期待 vs 実際）
- [ ] 期待されるDB状態を定義した
- [ ] 仮説を列挙した

### デバッグ中

- [ ] ターミナルコマンドにタイムアウトを付けた
- [ ] 計装にはリージョンマーカーを付けた（`#region agent log`）
- [ ] 仮説IDをログに含めた

### デバッグ完了後

- [ ] 計装コードを削除した
- [ ] 根本原因を特定し、最小修正を行った
- [ ] テストで修正を検証した
