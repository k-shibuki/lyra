---
alwaysApply: true
---
# E2E Debugging Conventions

## Positioning (Separation of Policy and Procedure)

- This file defines **policies (principles and constraints)**.
- Specific procedures (checklists, commands, query collections) are documented in `@.cursor/commands/debug-e2e.md`.

## Purpose

Achieve reproducible and efficient problem resolution when debugging to complete E2E scenarios (such as `docs/S_FULL_E2E.md`).

---

## 0. Basic Debugging Principles

### 0.1 Autonomous Execution Principle

- **AI executes autonomously**: AI directly executes terminal commands, test scripts, and DB queries without asking user to perform operations
  - Exception: MCP server restart/reconnection requires user operation
  - If MCP tool returns `Tool not found`, request reconnection
- **Don't fix based on speculation**: Fix based on evidence from logs or instrumentation

### 0.2 Timeout Required

Terminal commands **must always have timeout set** to prevent hangs:

```bash
# Good: with timeout
timeout 30 uv run python -c "..."

# Bad: no timeout (hang risk)
uv run python -c "..."
```

**Recommended Timeout Values**:

| Operation | Timeout |
|-----------|---------|
| Environment check (make doctor, etc.) | 30s |
| DB operations/queries | 10s |
| MCP handler test | 30s |
| Search execution (queue_searches) | 120s |
| Page fetch/extraction | 60s |

### 0.3 MCP Server Log Verification

MCP server logs are output to `logs/lyra_YYYYMMDD.log`. Check with these commands:

```bash
make mcp-logs           # Show last 100 lines
make mcp-logs-f         # Follow in real-time (tail -f)
make mcp-logs-grep PATTERN="error"  # Pattern search
```

### 0.4 Hypothesis → Instrumentation → Verification Cycle

1. **Hypothesis Formation**: List possible causes from symptoms
2. **Instrumentation**: Add logs/assertions that can verify hypotheses
3. **Verification**: Reject or adopt hypotheses based on instrumentation results
4. **Iteration**: If hypothesis is rejected, move to next hypothesis

---

## 1. Instrumentation Guidelines

### 1.1 Log Format (NDJSON)

Debug logs are output in NDJSON format to `${PROJECT_ROOT}/.cursor/debug.log`:

```python
# #region agent log
import json
with open(".cursor/debug.log", "a") as f:
    f.write(json.dumps({
        "location": "src/xxx.py:LINE",
        "message": "desc",
        "data": {"key": "value"},
        "timestamp": __import__("time").time() * 1000,
        "sessionId": "debug-session",
        "hypothesisId": "A"
    }) + "\n")
# #endregion
```

### 1.2 Instrumentation Placement Rules

| Placement Location | Content to Record |
|-------------------|-------------------|
| Function entry | Argument values |
| Function exit | Return values |
| Branch points | Which branch was executed |
| Before/after external calls | API/DB call input/output |
| Exception catch | Exception type and message |

### 1.3 Hypothesis ID Naming Convention

- `A`, `B`, `C`, ... : Main hypotheses
- `A1`, `A2`, ... : Sub-hypotheses
- Include `hypothesisId` in each log for filtering during analysis

---

## 2. State-Based Debugging Principles

### 2.1 Define Expected State First

Before bug investigation, clarify "normal DB/queue/cache state":

1. **Reference ADR/Schema**: Check state transitions and constraints
2. **Verbalize Expected State**: Define "what should have happened" first
3. **Compare with Actual State**: Identify cause from differences

### 2.2 State Transition Verification Patterns

| Verification Target | Check Items |
|--------------------|-------------|
| Record lifecycle | Is transition created → active → completed/cancelled correct? |
| Foreign key integrity | Are child records orphaned when parent record is deleted? |
| Timestamps | Is created_at < updated_at < expires_at order correct? |
| Status transitions | Are there disallowed transitions (cancelled → active, etc.)? |

### 2.3 Inconsistency Detection Approaches

1. **Direct query**: `SELECT ... WHERE status NOT IN ('expected', 'values')`
2. **Count comparison**: Compare expected vs actual record counts between related tables
3. **Logical contradiction detection**: Search for logically impossible states like `expires_at < created_at`

---

## 3. Handling DB Lock Contention

### 3.1 Problem Recognition

When MCP server holds DB write lock (WAL WRITER lock), writes from other processes will hang.

**Verification method**:
```bash
fuser data/lyra.db  # Check processes using DB
```

### 3.2 Workarounds

| Scenario | Solution |
|----------|----------|
| E2E scenario execution | Call tools via MCP server (normal route, no problem) |
| Direct testing | Use isolated test DB (`test_database` fixture in `tests/conftest.py`) |
| Emergency | Test after MCP server restart (requires user operation) |

---

## 4. Checklists

### Before Starting Debug

- [ ] Accurately described symptoms (expected vs actual)
- [ ] Defined expected DB state
- [ ] Listed hypotheses

### During Debug

- [ ] Added timeout to terminal commands
- [ ] Added region markers to instrumentation (`#region agent log`)
- [ ] Included hypothesis ID in logs

### After Debug Completion

- [ ] Removed instrumentation code
- [ ] Identified root cause and made minimal fix
- [ ] Verified fix with tests

---

## 5. Python-Specific Pitfalls

### 5.1 `dict.get(key, default)` and `None` Values

**Problem**: `dict.get(key, default)` returns `None`, not `default`, when key exists with `None` value.

```python
# NG: When API response is {"externalIds": null}, returns None
external_ids = data.get("externalIds", {})  # → None

# OK: Use or pattern to convert None to empty dict
external_ids = data.get("externalIds") or {}  # → {}
```

**When to apply**:
- JSON parsing from external APIs
- Dictionary retrieval where value can be `None`

### 5.2 Exception Type Matching

**Problem**: Custom exception classes and external library exception classes are different.

```python
# NG: Cannot catch httpx.HTTPStatusError
from src.utils.api_retry import HTTPStatusError  # custom
except HTTPStatusError as e:  # httpx exception passes through

# OK: Catch both
import httpx
except httpx.HTTPStatusError as e:  # httpx exception
    ...
except HTTPStatusError as e:  # custom exception
    ...
```

**Verification method**: Check exception types thrown by `raise_for_status()` etc. in documentation.

### 5.3 Rate Limiter Application Scope

**Principle**: Apply Rate Limiter to all external call methods in API clients.

```python
# NG: Applied only to search()
async def search(self, query: str) -> list[Paper]:
    await limiter.acquire(self.name)
    ...

async def get_references(self, paper_id: str) -> list[Paper]:
    # No Rate Limiter → 429 on bulk requests
    ...

# OK: Applied to all methods
async def get_references(self, paper_id: str) -> list[Paper]:
    await limiter.acquire(self.name)
    try:
        ...
    finally:
        limiter.release(self.name)
```
